[33mcommit b4804aec254dbf787eceac7882ac6bae3e7203ee[m[33m ([m[1;36mHEAD -> [m[1;32mmain[m[33m)[m
Author: cwn <896535341@qq.com>
Date:   Sat Jul 5 16:17:48 2025 +0800

    1.ä¸ºrenameå­å‘½ä»¤æ·»åŠ move_toåŠŸèƒ½
    2.ä¿®å¤äº†renameå­å‘½ä»¤çš„ä¸€äº›bug
    3.ä¸ºrenameå­å‘½ä»¤æ·»åŠ äº†æ›´å¤šé”™è¯¯æç¤º

[1mdiff --git a/demand.typ b/demand.typ[m
[1mindex da17473..3b92525 100644[m
[1m--- a/demand.typ[m
[1m+++ b/demand.typ[m
[36m@@ -40,4 +40,9 @@[m
   - æ”¯æŒæ–‡ä»¶æœç´¢ã€æ–‡ä»¶æ¯”è¾ƒã€æ‰¹é‡é‡å‘½å[m
   - æ”¯æŒé¢„è§ˆæ–‡æœ¬æ–‡ä»¶ï¼Œå¹¶ä¸”æ”¯æŒé«˜äº®æ˜¾ç¤º done[m
   - æ”¯æŒæ–‡ä»¶å¤§å°æ˜¾ç¤º done[m
[31m-    [m
\ No newline at end of file[m
[32m+[m[41m[m
[32m+[m[32mtodo:[m[41m[m
[32m+[m[32mæ›¿æ¢åŠŸèƒ½ï¼Œæ’¤é”€åŠŸèƒ½ï¼Œé€’å½’æ·±åº¦ï¼Œæ–‡æœ¬é‡å‘½ååŠŸèƒ½ï¼ˆå·¦è¾¹æºæ–‡ä»¶åï¼Œå³è¾¹æ–°æ–‡ä»¶åï¼‰ï¼Œ[m[41m[m
[32m+[m[32mç§»åŠ¨åˆ°æ–°æ–‡ä»¶å¤¹åŠŸèƒ½ï¼Œä¿®æ­£åºå·åŠŸèƒ½ï¼ˆ(1)(1)(1)-ï¼(3)ï¼‰ï¼Œç±»ä¼¼makefileçš„ä¸€é”®è‡ªåŠ¨åŒ–é‡å‘½ååŠŸèƒ½ï¼Œ[m[41m[m
[32m+[m[32mæ·»åŠ ä¸­æ–‡ã€ç½—é©¬ç­‰å¤šç§åºå·çš„åŠŸèƒ½ï¼Œtargetä¸­åŒ¹é…ä¸åˆ°å˜é‡å°±è¿”å›æºå­—ç¬¦ï¼Œé«˜äº®æ˜¾ç¤ºåŒºåˆ†åŒ¹é…åˆ°çš„æ¨¡æ¿å˜é‡ï¼Œ[m[41m[m
[32m+[m[32mé…å¯¹æ–‡ä»¶åŒæ­¥é‡å‘½åï¼Œæ–‡ä»¶ååˆæ³•æ€§æ£€æµ‹ï¼ˆé•¿åº¦ã€å­—ç¬¦ï¼‰ï¼Œæ”¯æŒæ›´å¤šæ¨¡æ¿å˜é‡çš„è¿ç®—å¦‚å–å­—ç¬¦é•¿åº¦ç­‰[m
\ No newline at end of file[m
[1mdiff --git a/src/main.rs b/src/main.rs[m
[1mindex e35c673..a135bad 100644[m
[1m--- a/src/main.rs[m
[1m+++ b/src/main.rs[m
[36m@@ -21,7 +21,7 @@[m [muse crate::ls::ls_command;[m
 #[command(author, version, about, long_about = None)][m
 struct Args {[m
     /// è¦åˆ—å‡ºå†…å®¹çš„ç›®å½•è·¯å¾„ï¼Œé»˜è®¤ä¸ºå½“å‰ç›®å½•[m
[31m-    /// todo: - æ˜¯æ–‡ä»¶å¤¹ï¼Œ*æ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼Œ[m
[32m+[m[32m    // // todo: - æ˜¯æ–‡ä»¶å¤¹ï¼Œ*æ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼Œ[m
     #[arg(default_value = ".")][m
     directory: PathBuf,[m
 [m
[36m@@ -30,7 +30,6 @@[m [mstruct Args {[m
     author: bool,[m
 [m
     /// æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯[m
[31m-    ///[m
     /// æ˜¾ç¤ºçš„æ¡ç›®ï¼špermission, modified, file_name, size[m
     #[arg(short, long)][m
     long: bool,[m
[36m@@ -285,6 +284,28 @@[m [menum SubCommands {[m
         /// å¼€å¯é€šé…ç¬¦åŠŸèƒ½[m
         #[arg(short, long, default_value_t = false)][m
         wildcard: bool,[m
[32m+[m
[32m+[m[32m        /// å¼€å¯æ›¿æ¢åŠŸèƒ½ï¼Œå’Œæ™®é€šçš„æœç´¢æ›¿æ¢åŠŸèƒ½ä¸€è‡´[m
[32m+[m[32m        #[arg(short = 'R', long, default_value_t = false)][m
[32m+[m[32m        replace: bool,[m
[32m+[m
[32m+[m[32m        // /// é€’å½’æ·±åº¦ï¼Œé»˜è®¤ä¸º1[m
[32m+[m[32m        // #[arg(short = 'd', long, default_value_t = 1)][m
[32m+[m[32m        // recursive_depth: usize,[m
[32m+[m
[32m+[m[32m        /// é‡å‘½ååç§»åŠ¨åˆ°æ–°æ–‡ä»¶å¤¹[m
[32m+[m[32m        #[arg(short = 'm', long)][m
[32m+[m[32m        move_to: Option<String>,[m
[32m+[m
[32m+[m[32m        // /// é‡å‘½ååå¤åˆ¶åˆ°æ–°æ–‡ä»¶å¤¹[m
[32m+[m[32m        // #[arg(short = 'c', long)][m
[32m+[m[32m        // copy_to: Option<String>,[m
[32m+[m
[32m+[m[32m        /// æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼Œå¦‚å˜é‡å¯¹åº”çš„å®é™…å€¼ç­‰[m
[32m+[m[32m        #[arg(short = 'i', long, default_value_t = false)][m
[32m+[m[32m        info: bool,[m
[32m+[m
[32m+[m[41m        [m
     },[m
     //todo: æ‰¹é‡ç§»åŠ¨ã€å‹ç¼©æ–‡ä»¶ã€æ•´åˆæ–‡ä»¶[m
 }[m
[36m@@ -345,8 +366,19 @@[m [mfn main() {[m
             regex,[m
             pattern,[m
             wildcard,[m
[32m+[m[32m            move_to,[m
[32m+[m[32m            info,[m
[32m+[m[32m            replace,[m
         }) => {[m
[31m-            let _ = rename_command(source, target, directory, regex, pattern, wildcard);[m
[32m+[m[32m            let _ = rename_command([m
[32m+[m[32m                source,[m
[32m+[m[32m                target,[m
[32m+[m[32m                directory,[m
[32m+[m[32m                regex,[m
[32m+[m[32m                pattern,[m
[32m+[m[32m                wildcard,[m
[32m+[m[32m                move_to[m
[32m+[m[32m            );[m
         }[m
         None => {[m
             ls_command([m
[1mdiff --git a/src/rename/rename.rs b/src/rename/rename.rs[m
[1mindex bddb6f5..25a2b7e 100644[m
[1m--- a/src/rename/rename.rs[m
[1m+++ b/src/rename/rename.rs[m
[36m@@ -28,6 +28,7 @@[m [mpub fn rename_command([m
     regex: bool,[m
     pattern: bool,[m
     wildcard: bool,[m
[32m+[m[32m    move_to: Option<String>,[m
 ) -> Result<bool> {[m
     // println!("Renaming '{}' to '{}'...", source, target);[m
     // å¤„ç†æµç¨‹ï¼š[m
[36m@@ -37,7 +38,13 @@[m [mpub fn rename_command([m
     // å°†targetä¸­çš„å­—ç¬¦ä¸²åˆ†å‰²æˆå˜é‡å’Œå­—ç¬¦çš„åˆ—è¡¨[m
     // å°†åˆ—è¡¨ä¸­çš„å˜é‡æ›¿æ¢æˆå…·ä½“çš„å€¼ï¼Œè¿™ä¸ªå€¼å¦‚æœä¸åœ¨ç»„é‡Œï¼Œé‚£å°±å°è¯•ä»é€šé…ç¬¦æˆ–è€…å…ƒæ•°æ®ä¸­è·å–lï¼›å¹¶ä¸”å¤„ç†ç‰¹æ®Šå­—ç¬¦[m
     // å°†å­—ç¬¦å’Œå˜é‡æ‹¼æ¥æˆå­—ç¬¦ä¸²[m
[31m-    let path_entries = Path::new(directory.as_str()).read_dir()?;[m
[32m+[m[32m    let path_entries = match Path::new(directory.as_str()).read_dir() {[m
[32m+[m[32m        std::result::Result::Ok(path_entries) => path_entries,[m
[32m+[m[32m        Err(e) => {[m
[32m+[m[32m            println!("{}", e);[m
[32m+[m[32m            return Err(anyhow!(e));[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
     let mut paths = Path::new(directory.as_str())[m
         .read_dir()?[m
         .map(|entry| {[m
[36m@@ -51,35 +58,54 @@[m [mpub fn rename_command([m
                 .to_string()[m
         })[m
         .collect::<Vec<String>>();[m
[32m+[m
[32m+[m[32m    // é€šé…ç¬¦å’Œæ¨¡æ¿åŒ¹é…éƒ½ä¸å¼€å¯çš„æƒ…å†µï¼Œæ­¤æ—¶åªéœ€è¦åˆ¤æ–­sourceå¯¹åº”çš„æ–‡ä»¶æ˜¯å¦å­˜åœ¨å³å¯[m
     if !pattern && !wildcard {[m
         if !regex {[m
             let path_entry = Path::new(source.as_str());[m
             if path_entry.exists() {[m
[31m-                return rename_single_file(&path_entry, &target);[m
[32m+[m[32m                return rename_single_file(&path_entry, &target, move_to);[m
             }[m
         } else {[m
             let re = Regex::new(&source)?;[m
             for p in path_entries {[m
                 if let std::result::Result::Ok(p) = p {[m
                     if re.is_match(p.file_name().as_os_str().to_str().unwrap())? {[m
[31m-                        return rename_single_file(&p.path(), &target);[m
[32m+[m[32m                        return rename_single_file(&p.path(), &target, move_to);[m
                     }[m
                 }[m
             }[m
         }[m
     }[m
[32m+[m
     let value_map = if pattern {[m
[32m+[m[32m        // ä¸ºæ¨¡æ¿å˜é‡èµ‹å€¼[m
         extract_named_groups(&mut paths, &source).unwrap_or(vec![HashMap::new(); paths.len()])[m
     } else {[m
[31m-        //todo:æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼çš„åŒ¹é…[m
[31m-        let path_entry = Path::new(source.as_str());[m
[31m-        if path_entry.exists() {[m
[31m-            paths = vec![path_entry.file_name().unwrap().to_string_lossy().to_string()];[m
[31m-        }[m
[31m-        else{[m
[31m-            println!("Can not find the file!");[m
[32m+[m[32m        /////todo:æ·»åŠ æ­£åˆ™è¡¨è¾¾å¼çš„åŒ¹é…[m
[32m+[m[32m        if regex {[m
[32m+[m[32m            let path_entry = Path::new(source.as_str());[m
[32m+[m[32m            if path_entry.exists() {[m
[32m+[m[32m                paths = vec![[m
[32m+[m[32m                    path_entry[m
[32m+[m[32m                        .file_name()[m
[32m+[m[32m                        .unwrap()[m
[32m+[m[32m                        .to_string_lossy()[m
[32m+[m[32m                        .to_string(),[m
[32m+[m[32m                ];[m
[32m+[m[32m            } else {[m
[32m+[m[32m                println!("Can not find the file!");[m
                 return Err(anyhow!("Can not find the file!"));[m
[32m+[m[32m            }[m
[32m+[m[32m        } else {[m
[32m+[m[32m            let re = Regex::new(&source).unwrap();[m
[32m+[m[32m            paths = paths[m
[32m+[m[32m                .iter()[m
[32m+[m[32m                .filter(|p| re.is_match(p).unwrap())[m
[32m+[m[32m                .map(|p| p.to_string())[m
[32m+[m[32m                .collect();[m
         }[m
[32m+[m
         vec![HashMap::new()][m
     };[m
     println!("value_map: {:?}", value_map);[m
[36m@@ -88,7 +114,7 @@[m [mpub fn rename_command([m
         println!("Can not find the file!");[m
         return Err(anyhow!("Can not find the file!"));[m
     }[m
[31m-    let res = rename_batch(paths, value_map, target, wildcard);[m
[32m+[m[32m    let res = rename_batch(paths, value_map, target, wildcard, move_to);[m
     match res {[m
         std::result::Result::Ok(_) => {[m
             // println!("Rename success");[m
[36m@@ -128,34 +154,72 @@[m [mfn wait_for_yes_no() -> bool {[m
     }[m
 }[m
 [m
[31m-fn rename_single_file(path: &Path, target: &str) -> Result<bool> {[m
[32m+[m[32mfn rename_single_file(path: &Path, target: &str, move_to: Option<String>) -> Result<bool> {[m
     println!([m
         "å°† '{}' é‡å‘½åä¸º '{}'",[m
         path.file_name().unwrap().to_string_lossy(),[m
         target.green()[m
     );[m
[32m+[m[32m    if move_to.is_some() {[m
[32m+[m[32m        let move_to_path = Path::new(move_to.as_ref().unwrap());[m
[32m+[m[32m        if !move_to_path.exists() {[m
[32m+[m[32m            println!("ç›®æ ‡æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {}", move_to_path.display());[m
[32m+[m[32m            return Err(anyhow!("ç›®æ ‡æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {}", move_to_path.display()));[m
[32m+[m[32m        } else {[m
[32m+[m[32m            println!("å¹¶ç§»åŠ¨åˆ°ç›®å½•: {}", move_to_path.display());[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
     let yes_no = wait_for_yes_no();[m
     if yes_no {[m
         let new_path = path.with_file_name(target);[m
[31m-        std::fs::rename(path, new_path)?;[m
[32m+[m[32m        std::fs::rename(path, &new_path)?;[m
[32m+[m[32m        let move_to_path = Path::new(move_to.as_ref().unwrap()).with_file_name(target);[m
[32m+[m[32m        if move_to_path.exists() {[m
[32m+[m[32m            println!("ç›®æ ‡æ–‡ä»¶å¤¹å·²å­˜åœ¨: {}", move_to_path.display());[m
[32m+[m[32m            return Err(anyhow!("ç›®æ ‡æ–‡ä»¶å¤¹å·²å­˜åœ¨: {}", move_to_path.display()));[m
[32m+[m[32m        }[m
[32m+[m[32m        std::fs::copy(&new_path, move_to_path)?;[m
[32m+[m[32m        std::fs::remove_file(new_path)?;[m
         return Ok(true);[m
     }[m
     return Ok(false);[m
 }[m
 [m
[31m-fn rename_batch_files(paths: &Vec<String>, target: &Vec<String>) -> Result<bool> {[m
[32m+[m[32mfn rename_batch_files([m
[32m+[m[32m    paths: &Vec<String>,[m
[32m+[m[32m    target: &Vec<String>,[m
[32m+[m[32m    move_to: Option<String>,[m
[32m+[m[32m) -> Result<bool> {[m
     let mut success = true;[m
     println!("é‡å‘½å:");[m
     for (i, path) in paths.iter().enumerate() {[m
         println!("{} -> {}", path, target[i].green());[m
     }[m
[32m+[m[32m    if move_to.is_some() {[m
[32m+[m[32m        let move_to_path = Path::new(move_to.as_ref().unwrap());[m
[32m+[m[32m        if !move_to_path.exists() {[m
[32m+[m[32m            println!("ç›®æ ‡æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {}", move_to_path.display());[m
[32m+[m[32m            return Err(anyhow!("ç›®æ ‡æ–‡ä»¶å¤¹ä¸å­˜åœ¨: {}", move_to_path.display()));[m
[32m+[m[32m        } else {[m
[32m+[m[32m            println!("å¹¶ç§»åŠ¨åˆ°ç›®å½•: {}", move_to_path.display());[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
     let yes_no = wait_for_yes_no();[m
     if yes_no {[m
         for (i, path) in paths.iter().enumerate() {[m
             let new_path = Path::new(path).with_file_name(&target[i]);[m
[31m-            let res = std::fs::rename(path, new_path);[m
[32m+[m[32m            let res = std::fs::rename(path, &new_path);[m
             match res {[m
[31m-                std::result::Result::Ok(_) => {}[m
[32m+[m[32m                std::result::Result::Ok(_) => {[m
[32m+[m[32m                    let move_to_path =[m
[32m+[m[32m                        Path::new(move_to.as_ref().unwrap()).with_file_name(&target[i]);[m
[32m+[m[32m                    if move_to_path.exists() {[m
[32m+[m[32m                        println!("ç›®æ ‡æ–‡ä»¶å¤¹å·²å­˜åœ¨: {}", move_to_path.display());[m
[32m+[m[32m                        return Err(anyhow!("ç›®æ ‡æ–‡ä»¶å¤¹å·²å­˜åœ¨: {}", move_to_path.display()));[m
[32m+[m[32m                    }[m
[32m+[m[32m                    std::fs::copy(&new_path, move_to_path)?;[m
[32m+[m[32m                    std::fs::remove_file(new_path)?;[m
[32m+[m[32m                }[m
                 std::result::Result::Err(e) => {[m
                     println!("é‡å‘½åå¤±è´¥: {}", e);[m
                     success = false;[m
[36m@@ -179,6 +243,7 @@[m [mpub fn rename_batch([m
     value_map: Vec<HashMap<String, String>>,[m
     target: String,[m
     wildcard: bool,[m
[32m+[m[32m    move_to: Option<String>,[m
 ) -> Result<bool> {[m
     if value_map.len() != paths.len() {[m
         return Err(anyhow!("Value map length does not match paths length"));[m
[36m@@ -256,7 +321,8 @@[m [mpub fn rename_batch([m
         match part_type {[m
             0 => {[m
                 for (i, _path) in paths.iter().enumerate() {[m
[31m-                    final_paths[i].push_str(&part);[m
[32m+[m[32m                    let final_part = part.replace("\\{", "{").replace("\\{", "}");[m
[32m+[m[32m                    final_paths[i].push_str(&final_part);[m
                 }[m
             }[m
             1 => {[m
[36m@@ -305,7 +371,7 @@[m [mpub fn rename_batch([m
     // for (path, final_path) in paths.iter().zip(final_paths.iter()) {[m
     //     println!("Renaming '{}' to '{}'", path, final_path);[m
     // }[m
[31m-    rename_batch_files(&paths, &final_paths)[m
[32m+[m[32m    rename_batch_files(&paths, &final_paths, move_to)[m
 }[m
 [m
 /// ä½¿ç”¨å‘½åæ•è·ç»„æ‰¹é‡å¤„ç†æ‰©å±•æ­£åˆ™è¡¨è¾¾å¼[m
[36m@@ -593,6 +659,7 @@[m [mfn process_special_symbols(sources: &Vec<String>, pattern: &String) -> Result<Ve[m
     Ok(results)[m
 }[m
 [m
[32m+[m[32m//todo: æ·»åŠ fileéƒ¨åˆ†çš„å…ƒæ•°æ®[m
 /// è·å–å…ƒæ•°æ®[m
 /// # å‚æ•°[m
 /// - `path`: æ–‡ä»¶è·¯å¾„[m
